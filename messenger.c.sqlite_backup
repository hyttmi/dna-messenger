/*
 * DNA Messenger - CLI Messenger Implementation
 *
 * Phase 3: Local message storage and contact management
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/stat.h>
#include <errno.h>
#include "messenger.h"
#include "qgp_platform.h"

// Database schema
static const char *SCHEMA_SQL =
    "CREATE TABLE IF NOT EXISTS contacts ("
    "  id INTEGER PRIMARY KEY AUTOINCREMENT,"
    "  name TEXT UNIQUE NOT NULL,"
    "  fingerprint TEXT,"
    "  added_at INTEGER NOT NULL"
    ");"
    ""
    "CREATE TABLE IF NOT EXISTS conversations ("
    "  id INTEGER PRIMARY KEY AUTOINCREMENT,"
    "  contact_id INTEGER NOT NULL,"
    "  last_message_at INTEGER,"
    "  FOREIGN KEY (contact_id) REFERENCES contacts(id)"
    ");"
    ""
    "CREATE TABLE IF NOT EXISTS messages ("
    "  id INTEGER PRIMARY KEY AUTOINCREMENT,"
    "  conversation_id INTEGER NOT NULL,"
    "  direction TEXT NOT NULL," // 'sent' or 'received'
    "  sender TEXT NOT NULL,"
    "  recipient TEXT NOT NULL,"
    "  ciphertext BLOB NOT NULL,"
    "  ciphertext_len INTEGER NOT NULL,"
    "  plaintext TEXT," // Decrypted text (cached)
    "  created_at INTEGER NOT NULL,"
    "  FOREIGN KEY (conversation_id) REFERENCES conversations(id)"
    ");";

// ============================================================================
// HELPERS
// ============================================================================

static char* get_messenger_dir(void) {
    const char *home = qgp_platform_home_dir();
    if (!home) {
        return NULL;
    }

    size_t len = strlen(home) + strlen("/.dna") + 1;
    char *dir = malloc(len);
    if (!dir) {
        return NULL;
    }

    snprintf(dir, len, "%s/.dna", home);
    return dir;
}

static int ensure_messenger_dir(void) {
    char *dir = get_messenger_dir();
    if (!dir) {
        return -1;
    }

    // Create directory if it doesn't exist
    if (qgp_platform_mkdir(dir) != 0 && errno != EEXIST) {
        fprintf(stderr, "Error: Failed to create %s: %s\n", dir, strerror(errno));
        free(dir);
        return -1;
    }

    free(dir);
    return 0;
}

// ============================================================================
// INITIALIZATION
// ============================================================================

int messenger_init_database(sqlite3 *db) {
    char *err_msg = NULL;
    int rc = sqlite3_exec(db, SCHEMA_SQL, NULL, NULL, &err_msg);

    if (rc != SQLITE_OK) {
        fprintf(stderr, "SQL error: %s\n", err_msg);
        sqlite3_free(err_msg);
        return -1;
    }

    return 0;
}

messenger_context_t* messenger_init(const char *identity) {
    if (!identity) {
        fprintf(stderr, "Error: Identity required\n");
        return NULL;
    }

    // Ensure ~/.dna directory exists
    if (ensure_messenger_dir() != 0) {
        return NULL;
    }

    messenger_context_t *ctx = calloc(1, sizeof(messenger_context_t));
    if (!ctx) {
        return NULL;
    }

    // Set identity
    ctx->identity = strdup(identity);
    if (!ctx->identity) {
        free(ctx);
        return NULL;
    }

    // Get database path
    char *dir = get_messenger_dir();
    if (!dir) {
        free(ctx->identity);
        free(ctx);
        return NULL;
    }

    size_t path_len = strlen(dir) + strlen("/messages.db") + 1;
    ctx->db_path = malloc(path_len);
    if (!ctx->db_path) {
        free(dir);
        free(ctx->identity);
        free(ctx);
        return NULL;
    }

    snprintf(ctx->db_path, path_len, "%s/messages.db", dir);
    free(dir);

    // Open database
    int rc = sqlite3_open(ctx->db_path, &ctx->db);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Error: Cannot open database: %s\n", sqlite3_errmsg(ctx->db));
        free(ctx->db_path);
        free(ctx->identity);
        free(ctx);
        return NULL;
    }

    // Initialize schema
    if (messenger_init_database(ctx->db) != 0) {
        sqlite3_close(ctx->db);
        free(ctx->db_path);
        free(ctx->identity);
        free(ctx);
        return NULL;
    }

    // Initialize DNA context
    ctx->dna_ctx = dna_context_new();
    if (!ctx->dna_ctx) {
        fprintf(stderr, "Error: Failed to create DNA context\n");
        sqlite3_close(ctx->db);
        free(ctx->db_path);
        free(ctx->identity);
        free(ctx);
        return NULL;
    }

    printf("Messenger initialized for '%s'\n", identity);
    printf("Database: %s\n", ctx->db_path);

    return ctx;
}

void messenger_free(messenger_context_t *ctx) {
    if (!ctx) {
        return;
    }

    if (ctx->dna_ctx) {
        dna_context_free(ctx->dna_ctx);
    }

    if (ctx->db) {
        sqlite3_close(ctx->db);
    }

    free(ctx->db_path);
    free(ctx->identity);
    free(ctx);
}

// ============================================================================
// MESSAGE OPERATIONS
// ============================================================================

int messenger_send_message(messenger_context_t *ctx, const char *recipient, const char *message) {
    if (!ctx || !recipient || !message) {
        return -1;
    }

    printf("\n[Sending message to %s]\n", recipient);

    // Encrypt message
    uint8_t *ciphertext = NULL;
    size_t ciphertext_len = 0;
    const char *recipients[] = {recipient};

    dna_error_t err = dna_encrypt_message(
        ctx->dna_ctx,
        (const uint8_t*)message,
        strlen(message),
        recipients,
        1,
        ctx->identity,
        &ciphertext,
        &ciphertext_len
    );

    if (err != DNA_OK) {
        fprintf(stderr, "Error: Encryption failed: %s\n", dna_error_string(err));
        return -1;
    }

    printf("✓ Message encrypted (%zu bytes)\n", ciphertext_len);

    // Get or create conversation
    sqlite3_stmt *stmt;
    const char *sql_get_contact = "SELECT id FROM contacts WHERE name = ?";
    int rc = sqlite3_prepare_v2(ctx->db, sql_get_contact, -1, &stmt, NULL);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "SQL error: %s\n", sqlite3_errmsg(ctx->db));
        free(ciphertext);
        return -1;
    }

    sqlite3_bind_text(stmt, 1, recipient, -1, SQLITE_STATIC);
    rc = sqlite3_step(stmt);

    int contact_id = -1;
    if (rc == SQLITE_ROW) {
        contact_id = sqlite3_column_int(stmt, 0);
    }
    sqlite3_finalize(stmt);

    // If contact doesn't exist, create it
    if (contact_id == -1) {
        const char *sql_add_contact = "INSERT INTO contacts (name, added_at) VALUES (?, ?)";
        rc = sqlite3_prepare_v2(ctx->db, sql_add_contact, -1, &stmt, NULL);
        if (rc != SQLITE_OK) {
            fprintf(stderr, "SQL error: %s\n", sqlite3_errmsg(ctx->db));
            free(ciphertext);
            return -1;
        }

        sqlite3_bind_text(stmt, 1, recipient, -1, SQLITE_STATIC);
        sqlite3_bind_int64(stmt, 2, (sqlite3_int64)time(NULL));
        rc = sqlite3_step(stmt);
        sqlite3_finalize(stmt);

        if (rc != SQLITE_DONE) {
            fprintf(stderr, "SQL error: %s\n", sqlite3_errmsg(ctx->db));
            free(ciphertext);
            return -1;
        }

        contact_id = (int)sqlite3_last_insert_rowid(ctx->db);
    }

    // Get or create conversation
    const char *sql_get_conv = "SELECT id FROM conversations WHERE contact_id = ?";
    rc = sqlite3_prepare_v2(ctx->db, sql_get_conv, -1, &stmt, NULL);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "SQL error: %s\n", sqlite3_errmsg(ctx->db));
        free(ciphertext);
        return -1;
    }

    sqlite3_bind_int(stmt, 1, contact_id);
    rc = sqlite3_step(stmt);

    int conv_id = -1;
    if (rc == SQLITE_ROW) {
        conv_id = sqlite3_column_int(stmt, 0);
    }
    sqlite3_finalize(stmt);

    if (conv_id == -1) {
        const char *sql_add_conv = "INSERT INTO conversations (contact_id, last_message_at) VALUES (?, ?)";
        rc = sqlite3_prepare_v2(ctx->db, sql_add_conv, -1, &stmt, NULL);
        if (rc != SQLITE_OK) {
            fprintf(stderr, "SQL error: %s\n", sqlite3_errmsg(ctx->db));
            free(ciphertext);
            return -1;
        }

        sqlite3_bind_int(stmt, 1, contact_id);
        sqlite3_bind_int64(stmt, 2, (sqlite3_int64)time(NULL));
        rc = sqlite3_step(stmt);
        sqlite3_finalize(stmt);

        if (rc != SQLITE_DONE) {
            fprintf(stderr, "SQL error: %s\n", sqlite3_errmsg(ctx->db));
            free(ciphertext);
            return -1;
        }

        conv_id = (int)sqlite3_last_insert_rowid(ctx->db);
    }

    // Store message
    const char *sql_add_msg =
        "INSERT INTO messages (conversation_id, direction, sender, recipient, ciphertext, ciphertext_len, plaintext, created_at) "
        "VALUES (?, 'sent', ?, ?, ?, ?, ?, ?)";

    rc = sqlite3_prepare_v2(ctx->db, sql_add_msg, -1, &stmt, NULL);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "SQL error: %s\n", sqlite3_errmsg(ctx->db));
        free(ciphertext);
        return -1;
    }

    sqlite3_bind_int(stmt, 1, conv_id);
    sqlite3_bind_text(stmt, 2, ctx->identity, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, recipient, -1, SQLITE_STATIC);
    sqlite3_bind_blob(stmt, 4, ciphertext, (int)ciphertext_len, SQLITE_STATIC);
    sqlite3_bind_int(stmt, 5, (int)ciphertext_len);
    sqlite3_bind_text(stmt, 6, message, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 7, (sqlite3_int64)time(NULL));

    rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    free(ciphertext);

    if (rc != SQLITE_DONE) {
        fprintf(stderr, "SQL error: %s\n", sqlite3_errmsg(ctx->db));
        return -1;
    }

    int msg_id = (int)sqlite3_last_insert_rowid(ctx->db);
    printf("✓ Message stored (ID: %d)\n", msg_id);

    return 0;
}

int messenger_list_conversations(messenger_context_t *ctx) {
    if (!ctx) {
        return -1;
    }

    const char *sql =
        "SELECT c.name, COUNT(m.id) as msg_count, MAX(m.created_at) as last_msg "
        "FROM conversations cv "
        "JOIN contacts c ON cv.contact_id = c.id "
        "LEFT JOIN messages m ON cv.id = m.conversation_id "
        "GROUP BY c.name "
        "ORDER BY last_msg DESC";

    sqlite3_stmt *stmt;
    int rc = sqlite3_prepare_v2(ctx->db, sql, -1, &stmt, NULL);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "SQL error: %s\n", sqlite3_errmsg(ctx->db));
        return -1;
    }

    printf("\n=== Conversations ===\n\n");
    int count = 0;

    while ((rc = sqlite3_step(stmt)) == SQLITE_ROW) {
        const char *contact = (const char*)sqlite3_column_text(stmt, 0);
        int msg_count = sqlite3_column_int(stmt, 1);
        sqlite3_int64 last_msg = sqlite3_column_int64(stmt, 2);

        time_t t = (time_t)last_msg;
        char time_str[64];
        strftime(time_str, sizeof(time_str), "%Y-%m-%d %H:%M:%S", localtime(&t));

        printf("  %s (%d messages, last: %s)\n", contact, msg_count, time_str);
        count++;
    }

    sqlite3_finalize(stmt);

    if (count == 0) {
        printf("  (no conversations yet)\n");
    }

    printf("\n");
    return 0;
}

int messenger_list_messages(messenger_context_t *ctx, const char *contact) {
    if (!ctx) {
        return -1;
    }

    const char *sql;
    sqlite3_stmt *stmt;

    if (contact) {
        sql =
            "SELECT m.id, m.direction, m.sender, m.recipient, m.plaintext, m.created_at "
            "FROM messages m "
            "JOIN conversations cv ON m.conversation_id = cv.id "
            "JOIN contacts c ON cv.contact_id = c.id "
            "WHERE c.name = ? "
            "ORDER BY m.created_at ASC";

        int rc = sqlite3_prepare_v2(ctx->db, sql, -1, &stmt, NULL);
        if (rc != SQLITE_OK) {
            fprintf(stderr, "SQL error: %s\n", sqlite3_errmsg(ctx->db));
            return -1;
        }

        sqlite3_bind_text(stmt, 1, contact, -1, SQLITE_STATIC);
        printf("\n=== Messages with %s ===\n\n", contact);
    } else {
        sql =
            "SELECT m.id, m.direction, m.sender, m.recipient, m.plaintext, m.created_at "
            "FROM messages m "
            "ORDER BY m.created_at ASC";

        int rc = sqlite3_prepare_v2(ctx->db, sql, -1, &stmt, NULL);
        if (rc != SQLITE_OK) {
            fprintf(stderr, "SQL error: %s\n", sqlite3_errmsg(ctx->db));
            return -1;
        }

        printf("\n=== All Messages ===\n\n");
    }

    int count = 0;
    int rc;

    while ((rc = sqlite3_step(stmt)) == SQLITE_ROW) {
        int id = sqlite3_column_int(stmt, 0);
        const char *direction = (const char*)sqlite3_column_text(stmt, 1);
        const char *sender = (const char*)sqlite3_column_text(stmt, 2);
        const char *recipient = (const char*)sqlite3_column_text(stmt, 3);
        const char *plaintext = (const char*)sqlite3_column_text(stmt, 4);
        sqlite3_int64 created_at = sqlite3_column_int64(stmt, 5);

        time_t t = (time_t)created_at;
        char time_str[64];
        strftime(time_str, sizeof(time_str), "%Y-%m-%d %H:%M:%S", localtime(&t));

        const char *arrow = strcmp(direction, "sent") == 0 ? "->" : "<-";
        printf("[%d] %s %s %s: %s\n", id, sender, arrow, recipient,
               plaintext ? plaintext : "(encrypted)");
        printf("     %s\n\n", time_str);
        count++;
    }

    sqlite3_finalize(stmt);

    if (count == 0) {
        printf("  (no messages)\n\n");
    }

    return 0;
}

// ============================================================================
// CONTACT MANAGEMENT
// ============================================================================

int messenger_add_contact(messenger_context_t *ctx, const char *name, const char *pubkey_file) {
    if (!ctx || !name) {
        return -1;
    }

    // Check if contact already exists
    const char *sql_check = "SELECT id FROM contacts WHERE name = ?";
    sqlite3_stmt *stmt;
    int rc = sqlite3_prepare_v2(ctx->db, sql_check, -1, &stmt, NULL);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "SQL error: %s\n", sqlite3_errmsg(ctx->db));
        return -1;
    }

    sqlite3_bind_text(stmt, 1, name, -1, SQLITE_STATIC);
    rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);

    if (rc == SQLITE_ROW) {
        printf("Contact '%s' already exists\n", name);
        return 0;
    }

    // Add contact
    const char *sql_add = "INSERT INTO contacts (name, added_at) VALUES (?, ?)";
    rc = sqlite3_prepare_v2(ctx->db, sql_add, -1, &stmt, NULL);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "SQL error: %s\n", sqlite3_errmsg(ctx->db));
        return -1;
    }

    sqlite3_bind_text(stmt, 1, name, -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 2, (sqlite3_int64)time(NULL));

    rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr, "SQL error: %s\n", sqlite3_errmsg(ctx->db));
        return -1;
    }

    printf("✓ Contact '%s' added\n", name);

    // TODO: Import pubkey_file if provided

    return 0;
}

int messenger_list_contacts(messenger_context_t *ctx) {
    if (!ctx) {
        return -1;
    }

    const char *sql = "SELECT name, added_at FROM contacts ORDER BY name ASC";
    sqlite3_stmt *stmt;
    int rc = sqlite3_prepare_v2(ctx->db, sql, -1, &stmt, NULL);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "SQL error: %s\n", sqlite3_errmsg(ctx->db));
        return -1;
    }

    printf("\n=== Contacts ===\n\n");
    int count = 0;

    while ((rc = sqlite3_step(stmt)) == SQLITE_ROW) {
        const char *name = (const char*)sqlite3_column_text(stmt, 0);
        sqlite3_int64 added_at = sqlite3_column_int64(stmt, 1);

        time_t t = (time_t)added_at;
        char time_str[64];
        strftime(time_str, sizeof(time_str), "%Y-%m-%d", localtime(&t));

        printf("  %s (added: %s)\n", name, time_str);
        count++;
    }

    sqlite3_finalize(stmt);

    if (count == 0) {
        printf("  (no contacts)\n");
    }

    printf("\n");
    return 0;
}

int messenger_show_contact(messenger_context_t *ctx, const char *name) {
    if (!ctx || !name) {
        return -1;
    }

    printf("\n=== Contact: %s ===\n\n", name);

    // TODO: Show full contact details (fingerprint, key info, etc.)

    printf("  Name: %s\n", name);
    printf("  (details not yet implemented)\n\n");

    return 0;
}

int messenger_remove_contact(messenger_context_t *ctx, const char *name) {
    if (!ctx || !name) {
        return -1;
    }

    const char *sql = "DELETE FROM contacts WHERE name = ?";
    sqlite3_stmt *stmt;
    int rc = sqlite3_prepare_v2(ctx->db, sql, -1, &stmt, NULL);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "SQL error: %s\n", sqlite3_errmsg(ctx->db));
        return -1;
    }

    sqlite3_bind_text(stmt, 1, name, -1, SQLITE_STATIC);
    rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);

    if (rc != SQLITE_DONE) {
        fprintf(stderr, "SQL error: %s\n", sqlite3_errmsg(ctx->db));
        return -1;
    }

    if (sqlite3_changes(ctx->db) == 0) {
        printf("Contact '%s' not found\n", name);
        return -1;
    }

    printf("✓ Contact '%s' removed\n", name);
    return 0;
}

// ============================================================================
// IMPORT/EXPORT (for Phase 3 testing without network)
// ============================================================================

int messenger_import_message(messenger_context_t *ctx, const char *ciphertext_file) {
    // TODO: Implement message import for Phase 3 testing
    fprintf(stderr, "Error: messenger_import_message not yet implemented\n");
    return -1;
}

int messenger_export_message(messenger_context_t *ctx, int message_id, const char *output_file) {
    // TODO: Implement message export for Phase 3 testing
    fprintf(stderr, "Error: messenger_export_message not yet implemented\n");
    return -1;
}
